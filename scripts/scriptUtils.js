const fs = require('fs');
const path = require('path');
const escapeRegExp = require('lodash.escaperegexp');
const request = require('request-promise-native');
const crypto = require('crypto');

const AUTOGEN_MARKER = 'AUTOGENERATED';

const hasHanzi = (string, exceptions = '') => {
  const hanziRegex = new RegExp(`[${escapeRegExp(exceptions)}\u3400-\u9FBF]`, 'giu');
  return !!string.match(hanziRegex);
};
const isOnlyHanzi = (string, exceptions = '') => {
  let searchStr = string;
  if (exceptions.length > 0) {
    const exceptionsRegexp = new RegExp(`[${escapeRegExp(exceptions)}]`, 'giu');
    searchStr = searchStr.replace(exceptionsRegexp, '');
  }
  return !searchStr.split('').find((char) => !hasHanzi(char));
};
const trim = (text) => text.replace(/^\s+|\s+$/giu, '');
const fixNewlines = (text) => `${trim(text)}\n`;

const formatFullPatternName = (text) => `${text.replace(/matcher.*/giu, '')}Pattern`;

const requestWithCache = async (url, cacheDir = path.resolve(__dirname, '../cache')) => {
  const md5 = crypto.createHash('md5').update(url).digest('hex');
  const cacheFile = path.join(cacheDir, md5);
  if (fs.existsSync(cacheFile)) {
    console.log('loaded from cache');
    return fs.readFileSync(cacheFile, 'utf-8');
  }
  const result = await request(url);
  fs.writeFileSync(cacheFile, result);
  return result;
};

const getNumHanzi = (str) => str.split('').filter(hasHanzi).length;

const isPatternFileWriteable = (fileName) => {
  if (fs.existsSync(fileName)) {
    const contents = fs.readFileSync(fileName, 'utf-8');
    return contents.indexOf(AUTOGEN_MARKER) >= 0;
  }
  return true;
};

const writeOutTemplate = (fileName, template, force) => {
  if (isPatternFileWriteable(fileName) || force) {
    console.log(`Writing ${fileName}`);
    fs.writeFileSync(fileName, fixNewlines(template));
    return true;
  }
  console.log(
    `${fileName} already exists. Skipping. Run with -- -f to overwrite this file.`
  );
  return false;
};

const getPatternIndexRequireLine = (matcherName) =>
  `exports.${matcherName} = require('./${matcherName}');`;

const getPatternFileName = (fullPatternName) =>
  path.resolve(__dirname, `../src/patterns/${fullPatternName}.js`);

const getPatternTestFileName = (fullPatternName) =>
  path.resolve(__dirname, `../src/patterns/${fullPatternName}.test.js`);

const rewriteFileContents = (fileName, rewriteFunc) => {
  const contents = fs.readFileSync(fileName, 'utf-8');
  fs.writeFileSync(fileName, rewriteFunc(contents));
};

const rewritePatternIndex = (rewriteFunc) => {
  const matchersIndexFile = path.resolve(__dirname, '../src/patterns/index.js');
  rewriteFileContents(matchersIndexFile, rewriteFunc);
};

const overwriteStructures = (fullPatternName, structuresStr) => {
  const mainFileName = getPatternFileName(fullPatternName);
  let contents = fs.readFileSync(mainFileName, 'utf-8');
  contents = contents
    .replace(/name:.*\n.*description:/im, 'description:')
    .replace(/structures: \[[\s\S]*?\],/gim, '');
  const descriptionStart = contents.indexOf('description:');
  contents =
    contents.substr(0, descriptionStart) +
    structuresStr +
    contents.substr(descriptionStart);
  writeOutTemplate(mainFileName, contents, true);
};

const writeOutPattern = (fullPatternName, mainTemplate, testTemplate, force = false) => {
  const mainFileName = getPatternFileName(fullPatternName);
  const testFileName = getPatternTestFileName(fullPatternName);

  const mainWritten = writeOutTemplate(mainFileName, mainTemplate, force);
  const testWritten = writeOutTemplate(testFileName, testTemplate, force);
  let indexWritten = true;

  rewritePatternIndex((indexContents) => {
    if (indexContents.indexOf(`exports.${fullPatternName}`) >= 0) {
      console.log('Pattern already exists in index. Skipping.');
      indexWritten = false;
      return indexContents;
    }
    const requireStatement = getPatternIndexRequireLine(fullPatternName);
    const updatedIndex = `${indexContents.replace(/\s+$/, '')}\n${requireStatement}`;
    console.log('Updating patterns/index.js');
    return fixNewlines(updatedIndex);
  });

  return {
    mainWritten,
    testWritten,
    indexWritten,
  };
};

module.exports = {
  hasHanzi,
  getNumHanzi,
  isOnlyHanzi,
  getPatternFileName,
  rewritePatternIndex,
  rewriteFileContents,
  isPatternFileWriteable,
  getPatternIndexRequireLine,
  formatFullPatternName,
  getPatternTestFileName,
  overwriteStructures,
  trim,
  fixNewlines,
  writeOutPattern,
  requestWithCache,
};
